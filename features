=== Commands ===

animal [file.anml] [args...]    Run a file
animal --repl                   Start interactive REPL mode
animal --help                   Show this help message
animal --version                Show version information
animal --debug                  Enable debug mode
animal --time                   Measure execution time

=== List of Nodes ===

ShelterNode
MimicNode
FetchJSONNode
FetchCSVNode
SniffFileNode
DropAppendNode
FetchNode
DropNode
ListAccessNode
ListNode
NestDefNode
DotCallNode
StatementsNode
RoarNode
GrowlNode
VarAccessNode
VarAssignNode
ListenNode
FunctionDefNode
FunctionCallNode
NumberNode
BinOpNode
UnaryOpNode
StringNode
BoolNode
PounceNode
WhimperNode
HissNode
LeapNode
BestiaryNode
TrySymbolicNode
ThrowSymbolicNode 

== List of Built-in Functions ===

meow   >>>			2 meow 2 = 4
woof   >>>		    2 woof 2 = 0
moo    >>>			2 moo 2 = 4
drone  >>>		    2 drone 2 = 1
squeak >>>	        3 squeak 2 = 1
soar   >>>		    3 soar 2 = 6


roar   >>> 			roar "test" => "test"

-> 	   >>>		    is used as a sign of assignment, example:  x -> 5

howl   >>> 			howl factorial(n) {...}

sniffback >>>		sniffback returns the last evaluated expression in a function
    
growl/sniff/wag (if, elif, else) >>> growl n <= 1 {
				1 sniffback
			  } sniff n == 2 {
				roar "That doesn't seem right..."
			  } wag {
				n moo factorial(n woof 1) sniffback
			  }

pounce >>> 	works like "while"

pounce operation != "exit" {

}

leap ... from ... to ... >>> works like "for"

leap i from 1 to 15 {
    growl i squeak 4 == 0 {
        roar "FizzBuzz"
    } sniff i squeak 3 == 0 {
        roar "Fizz"
    } sniff i squeak 5 == 0 {
        roar "Buzz"
    } wag {
        roar i
    }
}

mimic ... { } >>> works similar to "switch"

x -> "ca"

mimic x {
  "dog" -> roar "woof"
  "cat" -> roar "meow"
  _ -> roar "???"
}

nest ... { } >>> works like simple classes

nest Cat {
    name
    howl meo() {
        roar this.name, "says Meow!"
    }
}

c -> Cat()
c.name -> "Whiskers"
c.meo()


:: -> commants

:: Here's a command!

listen (input) >>> 

roar "Enter first number: "
num1 -> listen


fetch_csv >>> assigns a csv file to a variable

c -> fetch_csv("examples/testing_files/data.csv")
roar c[1].age   :: 30

fetch_json >>> assigns a json file to a variable

j -> fetch_json("examples/testing_files/data.json")
roar j[0].name  :: Alice

whimper >>> break

:: POUNCE LOOP with WHIMPER (break)
x2 -> 5
pounce x2 > 0 {
    growl x2 == 3 {
        whimper
    }
    x2 -> x2 woof 1
}

hiss >> continue

:: POUNCE LOOP with HISS (continue skip)
x3 -> 5
y3 -> 0
pounce x3 > 0 {
    x3 -> x3 woof 1
    growl x3 == 3 {
        hiss
    }
    y3 -> y3 meow 1
}

roar "y3 after pounce with hiss:", y3  :: Should print 4



=== File Input/Output ===

:: Read/write file
drop("sample.txt", "Hello from Animal!")
content -> fetch("sample.txt")
roar content

:: Appending to the file
drop("sample.txt", "Start\n")
drop_append("sample.txt", "Line A\n")
drop_append("sample.txt", "Line B\n")
content -> fetch("sample.txt")
roar content


sniff_file >>> checks if the file exists

:: Checking if the file exists
growl sniff_file("sample.txt") {
    roar "Exists!"
} wag {
    roar "Missing!"
}



=== Try-catch blocks ===

*[
  roar "Inside first try block"
]*

*(
  roar "Caught classic error:" _error
)*

*{ 
	"first symbolic error" 
}*


=== Lists ===

nums -> [1, 2, 3]
nums.sniff(4)
nums.snarl()
roar nums

:: LIST HOWL (find index)
l -> [10, 20, 30]
idx -> l.howl(20)

roar "Index of 20:", idx  :: Should print 1

=== Headliners ===

%time  >>>		execution time measured
%debug >>> 		debug mode enabled

!shelter  >>> exporting functions, libraries etc

!shelter -> ["add", "multiply"]

howl add(a, b) {
    a meow b sniffback
}

howl multiply(a, b) {
    a moo b sniffback
}

howl internal_secret(x) {   :: hidden, not exported
    x meow 1000 sniffback
}

%bestiary >>> works for modules

%bestiary 'examples/math_utils.anml'

x -> add(2, 3)
y -> multiply(x, 2)
roar x
roar y

internal_secret(5) :: ERROR! not visible

=== SHEBANG ===

#!/usr/bin/env animal
roar "Hello from shebang script!"
roar __args__


=== Types ===
:: Variable assignment without type (dynamic)
a -> 123
roar a   :: Expect 123

b -> "hello"
roar b   :: Expect hello

:: Variable assignment with type
x: int -> 10
roar x   :: Expect 10

y: string -> "world"
roar y   :: Expect world

z: bool -> true
roar z   :: Expect true

:: Reassign with correct type
x -> 99
roar x   :: Expect 99

:: Reassign with WRONG type (should throw runtime error)
y -> 123   :: Expect TYPE MISMATCH ERROR


=== Standard Library ===

[list]
paw(x, min, max): clamp a number
nuzzle(a, b): merge two lists or two strings
burrow(n): create list of n nil elements
perch(list): return all permutations of a list
lick(list): flatten nested list into single list
howl(list, item): find index of item inside list
chase(x, n): repeat element x n times into a list
trace(list): cumulative sum of numbers in list
trail(list): get all prefixes of list (growing sublists from start)
pelt(value, times): repeat string representation of value n times
howlpack(list, item): find all indexes of item in list
nest(value, depth): wrap value in nested lists to specified depth
